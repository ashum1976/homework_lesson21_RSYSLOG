#  Сбор и анализ логов

####Домашнее задание по теме "Сбор и анализ логов":

**Задание:**

В вагранте поднимаем 2 машины web и log на web поднимаем nginx на log настраиваем центральный лог сервер на любой системе на выбор:
journald
rsyslog
все критичные логи с web должны собираться и локально и удаленно все логи с nginx должны уходить на удаленный сервер (локально только критичные) логи аудита должны также уходить на удаленную систему

**Решение:**


___

**SELinux разрешить клиентам доступ к серверу по нестандартному порту 35514**
    Добавяем порт к типу syslogd_port_t и всё работает, протокол -- TCP

    semanage port -a -t  syslogd_port_t -p tcp 35514  

**SELinux создадание модуля с нужными разрешениями:**

1. checkmodule -M -m syslog_audit.te -o syslog_audit.mod
2. semodule_package -m syslog_audit.mod -o syslog_audit.pp
3. semodule -i  syslog_audit.pp
[Файл разрешений для создания SELinux модуля](rsyslog_conf/syslog_audit.te)



#### Настройка rsyslog


Дополнительную конфигурацию по настройке и обработке входящих сообщений от клиентских компьютеров вынесем в отдельные конфигурационные файлы:

[Файл настройки запуска сервера и шаблоны обработки сообщений](rsyslog_conf/99-gconf.conf)  
[Файл обработки входящих сообщений](rsyslog_conf/remote_log.conf)

Удобнее создавать файлы обработки и файлы шаблонов, для каждого клиента отдельно


Дополнительную конфигурацию по обработке и логгированию событий для клиентского компьютера, вынесем в отдельный конфигурационный файл (05-srvrslauth_log.conf):

[Конфигурационный файл клиента](rsyslog_conf/05-srvrslauth_log.conf)


Ошибки в работе nginx-a будем записывать как локально в файл (error_log /var/log/nginx/error.log;), так и передавать на червер логов, с помощью модуля imfile (следим за изменением файла логов):

      >input(type="imfile"
      file="/var/log/audit/audit.log"
      tag="audit"
      reopenOnTruncate="on"


Начиная с версии nginx-a 1.7.1 директивы error_log и access_log, в конфигурационном файле nginx.conf, поддерживают запись в syslog. Поэтому настроим передачу логов непосредственно в самом файле nginx.conf, закоментировав стороку  "access_log  /var/log/nginx/access.log  main;" и добавив следующую:

    access_log syslog:server=192.168.10.11:35514,facility=local6,tag=nginx_acces,severity=info combined;

**Данные передаются по UDP протоколу !!!!**


Все данные с удалённого сервера, пишутся в папку /var/log/remote/client/, и там создаётся файл по имени IP адреса клиента, и имени программы которая генерировала сообщение.


### Настройка, rsyslog сервера для приёма сообщений

Rsyslog сервер можно настроить на прием лог сообщений от других хостов.

Для этого нужно просто изменить конфигурационный файл Syslog’a: /etc/rsyslog.conf, или создать отдельный файл в папке, например /etc/rsysylog.d/99-gconf.conf и вынести туда все настройки отличающиеся от настроек по умолчанию в  /etc/rsyslog.conf.

Для работы по протоколу UDP, на порту 514 (или задать свой порт 35514):

    module(load="imudp")
    input(type="imudp" port="35514")

Для работы по протоколу TCP, на порту 514 (или задать свой порт 35514):

    module(load="imtcp")
    input(type="imtcp" port="35514")

Syslog может работать сразу по обоим протоколам. Тогда нужно раскомментировать все вышеперечисленное.


- **Шаблон генерации имени файла:**

[Ссылка на офф документацию по шаблонам](https://www.rsyslog.com/doc/v8-stable/configuration/templates.html)

template (name="path_auth_save" type="string" string="/var/log/remote/%hostname%/system-auth-%hostname%.log")
template (name="path_all_save" type="string" string="/var/log/remote/%HOSTNAME%/system-all-%fromhost-ip%.log")

В шаблонах можно использовать ["свойства rsyslog"](https://www.rsyslog.com/doc/v8-stable/configuration/properties.html)
Запишем строчки генерации имён файлов, на основе шаблона, в отдельный файл, где прописываем все общие параметры запуска rsyslog. ---   /etc/rsysylog.d/99-gconf.conf


___

#   Общая теория, примеры, полезности.

#### Конфигурационный файл syslog.conf

Файл syslog.conf является главным конфигурационным файлом для демона syslogd. Конфигурационный файл syslog.conf представляет собой набор правил. Каждое правило есть — строка, состоящая из **селектора и действия**, разделенных пробелом или табуляцией. Селектор представляет собой запись в виде **_категория.приоритет_**. Селектор может состоять из нескольких записей **_категория.приоритет_**, разделенных символом «;» . **_Можно указывать несколько категорий в одном селекторе (через запятую)_**.  Поле **действие** — устанавливает журналируемое действие для селектора.

Получив сообщение для записи в журнал (от klogd, от локальной или удаленной программы), syslogd для каждого правила проверяет не подходит ли сообщение под шаблон, определяемый селектором. Если подходит, то выполняется указанное в правиле действие. Для одного сообщения м.б. выполнено произвольное количество действий (т.е. обработка сообщения не прекращается при первом успехе).

Сообщения с уровнем, равным или выше указанного в селекторе, и категорией, равной указанной в селекторе, считается подходящим. Звездочка перед точкой соответствует любой категории, после точки — любому уровню. Слово none после точки — никакому уровню для данной категории.

В синтаксисе конфигурационного файла можно поставить перед приоритетом знак **!**, чтобы показать, что действие не должно применяться, **начиная с этого уровня и выше**. Подобным образом, перед приоритетом можно поставить знак **=**, чтобы показать, что **правило применяется только к этому уровню**, или **!=**, чтобы показать, что **правило применяется ко всем уровням, кроме этого**.


**_Категория может быть следующей:_**

0. — kern —  Сообщения ядра
1. — user —  Сообщения пользовательских программ
2. — mail —  Сообщения от почтовой системы.
3. — daemon — Сообщения от тех системных демонов, которые в отличие от FTP или LPR не имеют выделенных специально для них категорий.
4. — auth — Все что связано с авторизацией пользователей, вроде login и su (безопасность/права доступа)
5. — syslog — Система протоколирования может протоколировать сообщения от самой себя.
6. — lpr — Сообщения от системы печати.
7. — news — Сообщения от сервера новостей. (в настоящее время не используется)
8. — uucp — Сообщения от UNIX-to-UNIX Copy Protocol. Это часть истории UNIX и вероятнее всего она вам никогда не понадобится (хотя до сих пор определенная часть почтовых сообщений доставляется через UUCP).
9. — cron — Сообщения от системного планировщика.
10. — authpriv — То же самое, что и auth, однако сообщения этой категории записываются в файл, который могут читать лишь некоторые пользователи (возможно, эта категория выделена потому, что принадлежащие ей сообщения могут содержать открытые пароли пользователей, которые не должны попадать на глаза посторонним людям, и следовательно файлы протоколов должны иметь соответствующие права доступа).
11. — ftp — При помощи этой категории вы сможете сконфигурировать ваш FTP сервер, что бы он записывал свои действия.
12. — NTP — сообщения сервера времени
13. — log audit
14. — log alert
15. — clock daemon — сообщения демона времени
с 16 по 23   local0 — local7 Зарезервированные категории для использования администратором системы. Категория local7 обычно используется для сообщений, генерируемых на этапе загрузки системы.
mark (не имеющая цифрового эквивалента) — присваивается отдельным сообщениям, формируемым самим демоном syslogd

**_Под приоритет, (степени важности) сообщений, заданы 8 уровней важности, которые кодируются числами от 0 до 7:_**

0. — emerg:   (старое название PANIC) — Чрезвычайная ситуация. Система неработоспособна.
1. — alert:   Тревога! Требуется немедленное вмешательство.
2. — crit:    Критическая ошибка (критическое состояние).
3. — err:     (старое название ERROR) — Сообщение об ошибке.
4. — warning: (старое название WARN) — Предупреждение.
5. — notice:  Информация о каком-то нормальном, но важном событии.
6. — info:    Информационное сообщение.
7. — debug:   Сообщения, формируемые в процессе отладки.


Согласно действию, указанному в правиле, сообщение может быть записано в следующие назначения:

* Обычный файл

Задается полным путем, начиная со слеша (/). Поставьте перед ним дефис (-), чтобы отменить синхронизацию файла после каждой записи. Это может привести к потере информации, но повысить производительность.

* Именованные каналы

Размещение перед именем файла символа канала (|) позволит использовать fifo (first in — first out, первый пришел — первый вышел) или именованный канал (named pipe) в качестве приемника для сообщений. Прежде чем запускать (или перезапускать) syslogd, необходимо создать fifo при помощи команды mkfifo. Иногда fifo используются для отладки.

* Терминал и консоль

Терминал, такой как /dev/console.

* Удаленная машина

Для отправки логов на другой сервер необходимо вместо лог файла указать конструкцию с "@" или "@@" (UDP или TCP соответственно) и ip-адрес сервера Syslog и порт:

- Отправлять все логи на 10.10.10.1 по протоколу UDP (Устаревший тип записи):

      *.* @10.10.10.1:35514 (прописать имя машины в /etc/hosts, или настроено в DNS-e и указывать по имени)

- Отправлять все логи на 10.10.10.1 по протоколу TCP(Устаревший тип записи):

      *.* @@10.10.10.1:35514 (прописать имя машины в /etc/hosts, или настроено в DNS-e и указывать по имени)

**Современный тип записи RainerScript,  для отправки данных на удалённую машину (категория authpriv.* важность любая) с использованием очереди, для сохранения данных в момент недоступности серера логов:**

      authpriv.* {
                  action(type="omfwd"
                  target="192.168.10.11"
                  port="35514"
                  protocol="tcp"
                  queue.type="linkedList"         # run asynchronously
                  queue.filename="fwdRule1"        # unique name prefix for spool files
                  queue.maxdiskspace="1g"         # 1gb space limit (use as much as possible)
                  queue.saveonshutdown="on"       # save messages to disk on shutdown
                  action.resumeRetryCount="-1")


                  }


* Список пользователей

Разделенный запятыми список пользователей, получающих сообщения (если пользователь зарегистрирован в системе). Сюда часто включается пользователь root.
    Все зарегистрированные пользователи
    Чтобы известить всех зарегистрированных пользователей при помощи команды wall, используйте символ звездочки (*).



# Аудит системных событий в Linux


### Подсистема аудита: архитектура и принцип работы

Подсистема аудита была добавлена в ядро Linux начиная с версии 2.6. Она предназначена для отслеживания критичных с точки зрения безопасности системных событий.

- запуск и завершение работы системы;
- чтение, запись и изменение прав доступа к файлам;
- инициация сетевых соединений;
- попытки неудачной авторизации в системе;
- изменение сетевых настроек;
- изменение информации о пользователях и группах;
- запуск и остановка приложений;
- выполнение системных вызовов.

Чтобы начать работать с подсистемой аудита, нужно установить пакет auditd (если он уже по умолчанию не установлен):

    dnf install audit
